# designator.py
# Copyright 2025 Roger Marsh
# Licence: See LICENCE (BSD licence)

"""Data structures to define a piece designator."""

from solentware_base.core.where import (
    EQ,
    OR,
    NOT,
    AND,
)

from pgn_read.core.constants import (
    FEN_WHITE_KING,
    FEN_BLACK_KING,
)

from ..filespec import (
    PIECESQUAREMOVE_FIELD_DEF,
    PIECEMOVE_FIELD_DEF,
    SQUAREMOVE_FIELD_DEF,
    NEWGAMES_FIELD_DEF,
    PARTIAL_FILE_DEF,
    NEWGAMES_FIELD_VALUE,
    PARTIALPOSITION_FIELD_DEF,
)
from ..constants import (
    ANY_WHITE_PIECE_NAME,
    ANY_BLACK_PIECE_NAME,
    EMPTY_SQUARE_NAME,
)

ALL_GAMES_MATCH_PIECE_DESIGNATORS = (
    ANY_WHITE_PIECE_NAME
    + ANY_BLACK_PIECE_NAME
    + EMPTY_SQUARE_NAME
    + FEN_WHITE_KING
    + FEN_BLACK_KING
)
del FEN_BLACK_KING


class Designator:
    """Sopport piece designator and transform filters."""

    def __init__(self, *args):
        """Initialise a Designator instance."""
        super().__init__(*args)
        self._designator_set = None  # [] if evaluate_symbol in this class?
        self._signature = None
        self._designator_squares = None
        self._designator_pieces = None

    @property
    def designator_set(self):
        """Return the piece designator set."""
        return self._designator_set

    @property
    def designator_squares(self):
        """Return the piece designator squares."""
        return self._designator_squares

    @property
    def signature(self):
        """Return the signature of the piece designator set."""
        return self._signature

    def where_eq_piece_designator(
        self, movenumber, variation_code, designator_set
    ):
        """Return list of selection phrases to evaluate a piece designator.

        The fieldname PieceSquareMove is now unavoidably a bit confusing,
        where move refers to a token in the movetext when the piece is on
        the square.  Nothing to do with move number in the movetext, which
        is the ChessQL meaning of move in this context.

        """
        anypiece = ANY_WHITE_PIECE_NAME + ANY_BLACK_PIECE_NAME
        psmfield = PIECESQUAREMOVE_FIELD_DEF
        pmfield = PIECEMOVE_FIELD_DEF
        smfield = SQUAREMOVE_FIELD_DEF
        psmds = set()
        pmds = set()
        emptyds = set()
        smds = set()
        for pdesignator in designator_set:
            if len(pdesignator) == 1:
                # Rules of chess imply whole piece designator finds all games
                # if any of 'A', 'a', 'K', 'k', '_', are in designator set.
                if pdesignator[0] in ALL_GAMES_MATCH_PIECE_DESIGNATORS:
                    self._where = " ".join(
                        (
                            pmfield,
                            EQ,
                            "".join(
                                (movenumber, variation_code, FEN_WHITE_KING)
                            ),
                        )
                    )
                    return
                pmds.add("".join((movenumber, variation_code, pdesignator[0])))
                continue
            if pdesignator[0] == EMPTY_SQUARE_NAME:
                sqr = pdesignator[1:]
                emptyds.add(
                    " ".join(
                        (
                            NOT,
                            smfield,
                            EQ,
                            "".join(
                                (
                                    movenumber,
                                    variation_code,
                                    sqr + ANY_WHITE_PIECE_NAME,
                                )
                            ),
                            AND,
                            NOT,
                            smfield,
                            EQ,
                            "".join(
                                (
                                    movenumber,
                                    variation_code,
                                    sqr + ANY_BLACK_PIECE_NAME,
                                )
                            ),
                            # Restrict sets generated by NOTs to games active
                            # at <movenumber, variation_code>.
                            # 'K' or 'k' achieve this from the rules of chess.
                            AND,
                            pmfield,
                            EQ,
                            "".join(
                                (movenumber, variation_code, FEN_WHITE_KING)
                            ),
                        )
                    )
                )
                continue
            if pdesignator[0] in anypiece:
                smds.add(
                    "".join(
                        (
                            movenumber,
                            variation_code,
                            pdesignator[1:] + pdesignator[0],
                        )
                    )
                )
                continue
            psmds.add(
                "".join(
                    (
                        movenumber,
                        variation_code,
                        pdesignator[1:] + pdesignator[0],
                    )
                )
            )

        # "... field eq 'a' or 'b' ..." is accepted provided there are no
        # 'not' phrases later.  Thus the emptyds phrases must be first.
        # "... field eq 'a' or field eq 'b' ..." ia accepted always.
        phrases = []
        if emptyds:
            phrases.append(OR.join("  ").join(emptyds))
        if psmds:
            phrases.append(" ".join((psmfield, EQ, OR.join("  ").join(psmds))))
        if pmds:
            phrases.append(" ".join((pmfield, EQ, OR.join("  ").join(pmds))))
        if smds:
            phrases.append(" ".join((smfield, EQ, OR.join("  ").join(smds))))
        if phrases:
            self._where = OR.join("  ").join(phrases)
