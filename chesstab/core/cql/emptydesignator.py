# emptydesignator.py
# Copyright 2025 Roger Marsh
# Licence: See LICENCE (BSD licence)

"""Chess Query Language (ChessQL) empty square piece designator.

A number of CQL filters need an empty square piece designator which is
not derived from text in a CQL query.  The 'ray' filter is an example.

The EmptyDesignator class provides evaluation of implied empty squares
between pieces.

"""
from solentware_base.core.where import (
    EQ,
    OR,
    NOT,
    AND,
)

from pgn_read.core.constants import FEN_WHITE_KING

from . import symbol
from ..filespec import (
    PIECEMOVE_FIELD_DEF,
    SQUAREMOVE_FIELD_DEF,
)
from ..constants import (
    ANY_WHITE_PIECE_NAME,
    ANY_BLACK_PIECE_NAME,
    EMPTY_SQUARE_NAME,
)


class EmptyDesignator(symbol.Symbol):
    """ChessQL empty designator class."""

    def __init__(self, *args):
        """Initialise an EmptyDesignator instance for token."""
        super().__init__(*args)
        self._designator_set = None
        self._designator_squares = None

    def expand_symbol(self):
        """Do own expanding."""
        self.expand_piece_designator()

    def evaluate_symbol(self, cqlfinder, movenumber, cache, constraint=None):
        """Override, evaluate empty designator.

        onstraint is ignored.

        """
        data = cache.get(self._token)
        if data is not None:
            self._data = data
            return
        self.where_eq_piece_designator(movenumber, "0")
        self.evaluate_statement(cqlfinder)
        cache[self._token] = self._data

    @property
    def designator_set(self):
        """Return the piece designator set."""
        return self._designator_set

    @property
    def designator_squares(self):
        """Return the piece designator squares."""
        return self._designator_squares

    def expand_piece_designator(self):
        """Expand a piece designator into a set of simple piece designators.

        The set is available in property designator_set.

        Return None.

        """
        self._designator_set = {EMPTY_SQUARE_NAME + self._token}
        self._designator_squares = frozenset(self._token)

    def get_pieces(self):
        """Return the piece type designator component of the piece designator.

        The absence of any piece type, including empty square, means any white
        or black piece.  In this case 'Aa' is returned.

        """
        return EMPTY_SQUARE_NAME

    def get_squares(self):
        """Return list of squares in the piece designator."""
        return [self._token]

    def where_eq_piece_designator(self, movenumber, variation_code):
        """Return list of selection phrases to evaluate a piece designator.

        The fieldname PieceSquareMove is now unavoidably a bit confusing,
        where move refers to a token in the movetext when the piece is on
        the square.  Nothing to do with move number in the movetext, which
        is the ChessQL meaning of move in this context.

        """
        pmfield = PIECEMOVE_FIELD_DEF
        smfield = SQUAREMOVE_FIELD_DEF
        designator_set = self._designator_set
        emptyds = set()
        for pdesignator in designator_set:
            sqr = pdesignator[1:]
            emptyds.add(
                " ".join(
                    (
                        NOT,
                        smfield,
                        EQ,
                        "".join(
                            (
                                movenumber,
                                variation_code,
                                sqr + ANY_WHITE_PIECE_NAME,
                            )
                        ),
                        AND,
                        NOT,
                        smfield,
                        EQ,
                        "".join(
                            (
                                movenumber,
                                variation_code,
                                sqr + ANY_BLACK_PIECE_NAME,
                            )
                        ),
                        # Restrict sets generated by NOTs to games active
                        # at <movenumber, variation_code>.  'K' or 'k'  achieve
                        # this from the rules of chess.
                        AND,
                        pmfield,
                        EQ,
                        "".join((movenumber, variation_code, FEN_WHITE_KING)),
                    )
                )
            )

        phrases = []
        if emptyds:
            phrases.append(OR.join("  ").join(emptyds))
        if phrases:
            self._where = OR.join("  ").join(phrases)
